Recall that the clique-width of a graph is the minimum number of colors required to construct the graph using a specific set of operations, as defined in Section 2.
We define the {\em clique-width of a formula} to be the clique-width of its signed incidence graph, i.e. the bipartite graph where variables are connected by an edge with clauses where they appear, and the edges are labeled with a sign according to whether the variable appears negated or non-negated in a clause.
Solving \#SAT is two-fold in this case: we first compute a parse tree for the formula of interest, and then use a dynamic algorithm to compute the number of satisfying assignments.

\subsection{Computing a parse tree}

\iffalse
\textbf{Rank-decomposition.}
A {\em rank-decomposition} is a branch decomposition of the cut-rank function as defined in Section 2.
It will be used in the next algorithm which computes the parse tree, and as such we give an algorithm by Oum \cite{DBLP:journals/talg/Oum08} for obtaining a rank-decomposition.
\begin{lemma}[\cite{DBLP:journals/talg/Oum08}]
	Given a graph $G$ with $n$ vertices, it is possible to decide whether $\mathbf{rw}(G) \leq k$, and if so, construct a rank-decomposition of $G$ of width at most $3k+1$, all in time $\mathcal{O}(n^4)$.
\end{lemma}
For two sets $A,B$, let $A \triangle B = (A \setminus B) \cup (B \setminus A)$.
The {\em local complementation} $*$ is an operation on a graph $G$ and a vertex $v$, such that $G * v = \{ xy \ | \ xv,yv \in E(G), x \neq y \}$.
Two graphs are {\em locally equivalent} if one can be obtained by applying a sequence of local complementations to the other.
The {\em pivoting} $\land$ is an operation on a graph $G$ and an edge $uv$, such that $G \land uv = G * u * v * u$. 

For a graph $G$ and two disjoint $A,B \subseteq V(G)$, a {\em blocking sequence} for $(A,B)$ in $G$ is a sequence $v_1, v_2, ..., v_m$ of distinct vertices in $V(G) \setminus (A \cup B)$ that satisfies the following:
\begin{enumerate}
	\item $\rho^*_G(A, B \cup \{v_1\}) > \rho_G^*(A,B)$, and
	\item for all $1 \leq i < m$, $\rho^*_G(A \cup \{v_i\}, B \cup \{v_{i+1}\}) > \rho_G^*(A,B)$, and
	\item $\rho^*_G(A \cup \{v_m\}, B) > \rho_G^*(A,B)$, and
	\item no proper subsequence satisfies any of the above.
\end{enumerate}
where $\rho_G^*(X,Y) = \text{rank}(\mathbf{A}_G[X,Y])$. Note that $\rho_G(X) = \rho_G^*(X, V(G) \setminus X)$.
An {\em auxiliary digraph} $D$ of $G$ is a graph with $V(D) = (V(G)\setminus (A\cup B)) \cup (a',b')$ that satisfies the following:
\begin{enumerate}
	\item $a'x \in E(D)$ if $\rho_G^*(A, B \cup \{x\}) > \rho_G^*(A,B)$, and
	\item $xb' \in E(D)$ if $\rho_G^*(A \cup \{x\}, B) > \rho_G^*(A,B)$, and
	\item $xy \in E(D)$ if $\rho_G^*(A \cup \{x\}, B \cup \{y\}) > \rho_G^*(A,B)$
\end{enumerate}
where $x,y \in V(G) \setminus (A \cup B)$ and they are distinct.

The Algorithm \ref{alg:cw-rank-decomp} operates as follows.
It accepts a graph $G$ and two disjoint subsets $A,B \subseteq V(G)$ as input and outputs a cut with minimal cut-rank function value.
For each $i \geq 0$, it attempts to find a blocking sequence in the auxiliary digraph.
If we meanwhile manage to find the set $Z$ minimizing $\rho_G(Z)$, then we output it, otherwise we fill a table \textbf{G}.
Its runtime is $\mathcal{O}(n^5)$ for a graph $G$ with $n$ vertices.

\begin{algorithm}
	\LinesNumbered
	\caption{Finding a set $Z$ minimizing $\rho_G(Z)$ \cite{DBLP:journals/talg/Oum08}}
	\label{alg:cw-rank-decomp}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$G$, a graph, and disjoint subsets $A,B \subseteq V(G)$}
	\Output{$Z \subseteq V(G)$ such that $A \subseteq Z \subseteq V(G) \setminus B$, and $\rho_G(Z)= \min_{A \subseteq Z \subseteq V(G)\setminus B} \rho_G(X)$}

	$\mathbf{G}_{0,0} \gets G$\;
	\ForEach{$i \geq 0$}{
		%$r \gets \texttt{BSeq}()$; \tcp{see Algorithm ?}
		construct the auxiliary digraph $D$ of $G$ with $V(D) = (V(G)\setminus (A\cup B)) \cup (a',b')$\;
		$p\gets$ shortest directed path from $a'$ to $b'$ in $D$\;
		\uIf{\em $p = \textsf{null}$}{
			$J\gets $ the set of ends of all directed paths from $a'$ with $\geq1$ edge\;
			$Z \gets A \cup J$\;
		}
		\uElse{
			$q \gets $ the shortest path s.t. $q = a',v_1,v_2,...,v_m,b'$\;
			$s \gets v_1,v_2,...,v_m$; \tcp{the blocking sequence}
		}
		\textbf{end}
		
		\uIf{$Z \neq \mathsf{null}$}{
			\Return $Z$
		}
		\uElse{
			\tcp{$s = v_1,v_2,...,v_m$}
			\ForEach{\em $0 \leq j < m$}{
				find the vertex $w\in B$ adjacent to $v^i_{m-j}$ in $\mathbf{G}_{i,j}$\;
				$\mathbf{G}_{i,j+1} \gets \mathbf{G}_{i,j} \land wv_{m-j}$\;
			}
			$\mathbf{G}_{i+1,0} \gets \mathbf{G}_{i,m}$\;
		}
	}
\end{algorithm}

------\\
\fi

\iffalse
\noindent
\textbf{Parse tree.}
Recall that a $k$-expression represents a sequence of operations (defined for clique-width) that results in a colored graph using at most $k$ colors.
Note that any $k$-expression can be represented as a tree, where the child (or children) are the arguments of the corresponding operation.
We define the signed parse tree $T^{\pm}_F$ of a formula $F$ to be a rooted tree whose leaves hold singleton colored graphs, internal nodes represent the operations (disjoint union, recoloring, renaming) defined for clique-width, and the root holds the signed incidence graph of $F$.
Using an algorithm presented in \cite{DBLP:journals/jct/OumS06} by Oum and Seymour, we can obtain a $k$-expression of the signed incidence graph, and as such the signed parse tree of a formula.
\begin{lemma}[\cite{DBLP:journals/jct/OumS06, DBLP:journals/dam/FischerMR08}]
	Given a signed graph $G$ with $n$ vertices, it is possible to decide whether $\mathbf{cw}(G) \leq k$, and if so, compute a $f(k)$-parse tree of $G$, where $f(k) = 3^{3k+\mathcal{O}(1)} = 2^{\mathcal{O}(k)}$, all in time $\mathcal{O}(n^9 \log n)$.
\end{lemma}
We describe in the following the aforementioned algorithm \cite{DBLP:journals/jct/OumS06}.
Recall from the definition of rank-width that, for a finite set $V$, the set function is a function $f : 2^V \rightarrow \mathbb{Z}$.
Let $3^V$ denote the set $\{ (X,Y) \ | \ X,Y \subseteq V,\, X \cap Y = \emptyset \}$.
Then we define the {\em interpolation} of a submodular set function $f$ (with $f(\emptyset) \leq f(X)$ for all non-empty $X \subseteq V$) to be the function $f^* : 3^V \rightarrow \mathbb{Z}$ such that:
\begin{itemize}
	\item[--] for all $X \subseteq V$, $f^*(X, V \setminus X)=f(X)$, and
	\item[--] if $C \cap D = \emptyset$, $A \subseteq C$, $B \subseteq D$, then $f^*(A,B) \leq f^*(C,D)$, and
	\item[--] for all $(A,B),(C,D) \in 3^V$, $f^*(A,B)+f^*(C,D) \geq f^*(A \cap C, B \cup D)$ \vspace{-4pt}
	
	$\phantom{w} + f^*(A \cup C, B \cap D)$, and
	
	\item[--] $f^*(\emptyset, \emptyset) = f(\emptyset)$.
\end{itemize}

\noindent
In particular, $f_{\min}(X,Y) = \min_{X \subseteq Z \subseteq V\setminus Y} f(Z)$ is an interpolation. \\

\noindent
---------
\textbf{[sketch]}

obtain a rank-decomposition $(T,L)$ of $G$;\\

for internal nodes, calculate $F$, the set of pairs $(i,j)$ with $i,j \in \{1,2,...,2^k\}$ such that $xy \in E(G)$ with $x \in D_{v_1}, lab_{v_1}(x)=i, y \in D_{v_2}, lab_{v_2}(y)=j$.
Where for $v \in V(T)$, $D_v = \{ x \in V(G) \ | \ L(x)$ is a decendant of $v$ in $T \}$, and $v_1, v_2$ are children of $v$; \\

then merge sets with neighbors outside $D_v$; ?? \\

don't understand how to compute the k-expression $t_v$ (just says ``let us choose''??)
\fi


















\noindent
Similarly to computation of branch decompositions using a SAT encoding in the previous section, we can determine the clique-width and construct a parse tree using the method described by Heule and Szeider \cite{DBLP:journals/tocl/HeuleS15}.
Recall that a $k$-expression is a well-formed expression using operators defined for clique-width and that it evaluates to a colored graph.
Moreover, a graph has clique-width $k$ iff it has a $k$-expression and $k$ is minimal.

\begin{theorem}[\cite{DBLP:journals/tocl/HeuleS15}]
	Given a graph $G$ with $n$ vertices, we can construct a formula $F(G,k)$ that is satisfiable if and only if $\mathbf{cw}(G) \leq k$, which has $\mathcal{O}(n^3-nk^2)$ variables and $\mathcal{O}(n^5-n^4k)$ clauses; and if so, we can construct a corresponding parse tree in polynomial time.
\end{theorem}

We introduce the necessary definitions and describe the construction of the formula as in \cite{DBLP:journals/tocl/HeuleS15}.
Let $G$ be a graph.
A {\em template} $T$ consists of partitions cmp$(T)$ and grp$(T)$ of $V(G)$.
Their equivalence classes are called components and groups, respectively, and intuitively represent induced subgraphs (for components) and sets of vertices with the same label in a component (for groups).
A {\em derivation} of length $t$ is a sequence of templates $D = (T_0, T_1, ..., T_t)$ fulfilling:
\begin{enumerate}
	\item[--] $|\text{cmp}(T_0)| = |V(G)|$ and $|\text{cmp}(T_t)|=1$, and
	\item[--] for $0 \leq i \leq t$, grp$(T_i)$ is a refinement of cmp$(T_i)$, and
	\item[--] for $1 \leq i \leq t$, cmp$(T_{i-1})$ is a refinement of cmp$(T_{i})$, and
	\item[--] for $1 \leq i \leq t$, grp$(T_{i-1})$ is a refinement of grp$(T_{i})$.
\end{enumerate}
This also implies $\text{grp}(T_0)=|V(G)|$.
The {\em width} of a component $c \in \text{cmp}(T)$ is the number of groups $g \in \text{grp}(T)$ such that $g \subseteq c$.
Then, the width of a template of a template is the maximum width over all its components, and the width of a derivation is the maximum width over all its templates.
A derivation of width $k$ is also called a $k$-derivation.
We say that $D=(T_0,T_1,...,T_t)$ is a derivation of a graph $G$ if the following holds:
\begin{enumerate}
	\item[--] for any $u,v \in V(G)$ with $uv\in E(G)$, if $u,v$ are in the same group in $T_i$, then $u,v$ are in the same component in $T_{i-1}$, and
	\item[--] for any $u,v,w \in V(G)$ with $uv \in E(G)$ and $uw \not\in E(G)$, if $u,v$ are in the same group in $T_i$, then $u,v$ are in the same component in $T_{i-1}$, and
	\item[--] for any $u,v,w,x \in V(G)$ with $uv,uw,vx \in E(G)$ and $wx \not\in E(G)$, if $u,x$ are in the same group in $T_i$ and $v,w$ are in the same group in $T_i$, then $u,v$ are in the same component in $T_{i-1}$.
\end{enumerate}
In contrast to a $k$-expression, a $k$-derivation may define more than one graph.
A derivation is said to be {\em strict} if for all $1 \leq i \leq t$, $|\text{cmp}(T_{i-1})| > |\text{cmp}(T_i)|$.
Moreover, every $k$-derivation of a graph contains its strict $k$-derivation as a subsequence.

We assume that the vertices of a graph $G$ are represented using integers, and for $u,v \in V(G)$ we define $u<v$ according to their integer representations.
First we construct the formula $F(G,t,k)$ that is satisfiable iff $G$ has a $k$-derivation of length $t$, and introduce the following variables:
\begin{itemize}
	\item[--] {\em component variable} $c(u,v,i)$ is true iff $u,v$ are in the same component in template $T_i$,
	\item[--] {\em group variable} $g(u,v,i)$ is true iff $u,v$ are in the same group in template $T_i$,
	\item[--] {\em representative variable} $r(v,i)$ is true iff $v$ is the smallest vertex in some group in template $T_i$,
	\item[--] {\em order variable} $o(v,a,i)$, an auxiliary variable to restrict the number of representative vertices.
\end{itemize}
The formula $F(G,t,k)$ contains the following clauses:
\begin{enumerate}
	\item $\neg c(u,v,0) \land c(u,v,t) \land (c(u,v,i) \lor \neg g(u,v,i)) $ \vspace{-4pt}
	
	$\land \ (\neg c(u,v,i-1) \lor c(u,v,i))\land (\neg g(u,v,i-1) \lor g(u,v,i))$,
	
	for $u,v \in V(G),\, u<v,\, 0 \leq i \leq t$;
	
	\item $(\neg c(u,v,i) \lor \neg c(v,w,i) \lor c(u,w,i)) \land (\neg c(u,v,i) \lor \neg c(u,w,i) \lor c(v,w,i))$ \vspace{-4pt}
	
	$\land \ (\neg c(u,w,i) \lor \neg c(v,w,i) \lor c(u,v,i)) \land (\neg g(u,v,i) \lor \neg g(v,w,i) \lor g(u,w,i))$ \vspace{-16pt}
	
	$\land \ (\neg g(u,v,i) \lor \neg g(u,w,i) \lor g(v,w,i)) \land (\neg g(u,w,i) \lor \neg g(v,w,i) \lor g(u,v,i))$, \vspace{-12pt}
	
	for $u,v,w \in V(G),\, u<v<w,\, 0 \leq i \leq t$;
	
	\item $(c(u,v,i-1) \lor \neg g(u,v,i))$, for all $u,v \in V(G),\, u<v,\, uv \in E(G),\, 1 \leq i \leq t$;
	
	\item $(c(\min\{u,v\}, \max\{u,v\}, i-1) \lor \neg g(\min\{v,w\}, \max\{v,w\}, i))$,
	
	for all $u,v,w \in V(G),\, uv \in E(G),\, uw \not\in E(G),\, 1 \leq i \leq t$;
	
	\item $(c(u,v,i-1) \lor \neg g(\min\{u,x\}, \max\{u,x\}, i) ) \lor \neg g(\min\{v,w\}, \max\{v,w\}, i) )$,
	
	for all $u,v,w,x \in V(G),\, uv,uw,vx \in E(G),\, wx \not\in E(G),\, 1 \leq i \leq t$;
	
	\item $(r(v,i) \lor \bigvee_{u\in V(G), u<v} g(u,v,i)) \land \bigwedge_{u \in V(G), u<v} (\neg r(v,i) \lor \neg g(u,v,i))$,
	
	for all $v \in V(G),\, 0 \leq i \leq t$;
	
	\item $(\neg c(u,v,i) \lor \neg r(u,i) \lor \neg r(v,i) \lor \neg o(u,k-1,i))$ \vspace{-4pt}
	
	$\land \ (\neg c(u,v,i) \lor \neg r(u,i) \lor \neg r(v,i) \lor \neg o(v,1,i))$ \vspace{-4pt}
	
	$\land \ \bigwedge_{1 \leq a < k-1} (\neg c(u,v,i) \lor \neg r(u,i) \lor \neg r(v,i) \lor \neg o(u,a,i) \lor o(v,a+1,i))$,
	
	for all $u,v \in V(G),\, u<v,\, 0 \leq i \leq t$.
\end{enumerate}
The clauses 1 ensure that the definition of a derivation is fulfilled.
The clauses 2 ensure transitivity of being in the same group or component.
The clauses 3--5 restrict the derivations to fulfil the properties of being derivations of a graph.
The clauses 6 enforce that only one vertex can be the representative of a group, and the clauses 7 ensure that the number of representatives in a component is at most $k$.
Overall, this encoding requires $n(n+k-1)(n-k+2)$ variables and $\mathcal{O}(n^5-n^4k)$ clauses.

The formula $F(G,t,k)$ is satisfiable if and only if the graph $G$ has a $k$-derivation of length $t$.
It has been shown that a graph $G$ with $n$ vertices has $\mathbf{cw}(G) \leq k$ iff it has a $k$-derivation of length $n-k+1$.
As such we fix $t:= n-k+1$ to obtain a formula $F(G,k) := F(G,n-k+1,k)$ that is satisfiable iff $\mathbf{cw}(G) \leq k$.

Having obtained a satisfying assignment, we can easily construct a $k$-derivation of the graph.
Then we can compute a $k$-expression in polynomial time as follows.
We first make the $k$-derivation strict.
Assume there is some $1 \leq i \leq t$ such that cmp$(T_{i-1}) = $ cmp$(T_i)$.
Then we just remove $T_i$ and obtain also a $k$-derivation.
This is repeated until there is no such $i$, that is until the derivation is strict.
Now we can assume $D = (T_0, T_1, ..., T_t)$ is a strict $k$-derivation of the graph $G$.
%Let $C = \bigcup_{i=0}^{i=t} \text{cmp}(T_i)$.

For each component $c = \{v\} \in \text{cmp}(T_0)$ (which consist of one vertex each) we create a leaf $v$ that represents a singleton, and assign to it the color 1.
Then, for each $1 \leq i \leq t$ and each $c \in \text{cmp}(T_i)$, we create an internal node $q_{c,i}$ representing the disjoint union $\oplus$, and add edges such that $q_{c', i-1}$ is a child of $q_{c,i}$ iff $c' \subseteq c$.
We now traverse the tree in depth first order while adding nodes that represent recoloring $\rho$.
For every currently visited node $q_{c,i}$, we consider each of its children; we replace the edge with a path consisting of at most $k$ recoloring nodes, s.t. $q_{c,i}$ has a child $q'$ with grp$(G_{q'}) = \{ g\in \text{grp}(G_{q_{c,i}}) \ | \ g \subseteq c \} \subseteq \text{grp}(T_i)$, where $G_v$ denotes the graph equivalent to the $k$-expression at $v$.
Finally we add nodes representing edge creation $\mu$: let $uv \in E(G)$, $q$ be the $\oplus$-node with smallest $i$ such that $u,v \in V(G_{q})$.
$u,v$ belong to different groups of $T_i$ and as such have different colorings in $G_q$. Let $u$ be colored $a$ and $v$ be colored $b$. Then we add a $\mu$-node $p$ such that $q$ is a child of $p$, and that represents edge creation $\mu_{a,b}$.
After performing these operations (which take polynomial time) we obtain a parse tree for $G$.









\subsection{Dynamic algorithm for \#SAT}

Now we solve \#SAT using an FPT algorithm (with the parameter being the clique-width of the formula), which was described by Fischer, Makowsky and Ravve in \cite{DBLP:journals/dam/FischerMR08}.

\begin{theorem}[\cite{DBLP:journals/dam/FischerMR08}]
	Given a CNF formula $F$ and a signed parse tree for clique-width $\leq k$ with $n$ vertices, \#SAT can be solved in time $2^{\mathcal{O}(\text{\em poly}(k))} \mathcal{O}(n)$.
\end{theorem}

\noindent
Let $F$ be a formula with a signed incidence graph whose vertices are colored with $\{ 1, 2, ..., k \}$.
For $A,B,C \subseteq \{ 1, 2, ..., k \}$ we define $F^{A,B,C}$ to be the formula obtained by performing the following operations:
\begin{enumerate}
	\item for every $a \in A$, remove such clauses from $A$ whose vertices are colored $a$;
	\item for every $b \in B$, add a clause that is a disjunction of all variables whose vertices are colored $b$;
	\item for every $c \in C$, add a clause that is a disjunction of negations of all variables whose vertices are colored $c$.
\end{enumerate}
\noindent
Note that $F = F^{\emptyset, \emptyset, \emptyset}$.

We assume that in the signed parse tree $T^{\pm}_F$, all disjoint unions are made between graphs whose color sets are disjoint.
Any parse tree that violates this and uses $k$ colors can be easily transformed into one that satisfies the condition and uses $2k$ colors.

We start at the leaves and fill a table $\mathbf{S}_v(A,B,C)$ for all $A,B,C \subseteq \{1, 2, ..., k \}$.
For any leaf $l$, the formula $F_l$ either contains one single variable or one empty clause, therefore we can easily fill the table out for these nodes.
For internal nodes, see Algorithm \ref{alg:cw-dynamic}, which uses the reduction lemmas that let us fill in the table based on the tables of the node's child (or children).
At the end, for the root node $r$, the table value $\mathbf{S}_r(\emptyset, \emptyset, \emptyset)$ stores the number of satisfying assignments of $F$.
For any node, the number of calculated values is singly exponential in $k$, each of which is computed in constant time.
As such, the complexity of the algorithm is linear in the size of $T^{\pm}_F$ and exponential in $k$.



% commented out â€“ reduction lemmas
\iffalse
\begin{lemma}[\cite{DBLP:journals/dam/FischerMR08}]
	Let $v$ be a node of $T^{\pm}_F$, $u,w$ its children, and the operation at $v$ is the disjoint union $F_u \oplus F_w$.
	Then $\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A,B,C) \cdot \mathbf{S}_w(A,B,C)$.
\end{lemma}

\begin{lemma}[\cite{DBLP:journals/dam/FischerMR08}]
	Let $v$ be a node of $T^{\pm}_F$, $u$ its child, and the operation at $v$ is recoloring $\rho_{i,j}(F_u)$.
	If $i \in B$ or $i \in C$, then $\mathbf{S}_v(A,B,C) = 0$.
	Otherwise:
	\begin{itemize}
		\item[--] if $j \not\in B$ and $j \not\in C$, then $\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B,C)$;
		\item[--] if $j \in B$ and $j \not\in C$, then \vspace{-4pt}
		
		$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B_1,C) + \mathbf{S}_u(A',B_2,C) - \mathbf{S}_u(A',B_3,C)$;
		
		\item[--] if $j \not\in B$ and $j \in C$, then \vspace{-4pt}
		
		$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B,C_1) + \mathbf{S}_u(A',B,C_2) - \mathbf{S}_u(A',B,C_3)$;
		
		\item[--] otherwise if $j \in B$ and $j \in C$, then \vspace{-4pt}
		
		$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B_1,C_1) + \mathbf{S}_u(A',B_1,C_2) + \mathbf{S}_u(A',B_2,C_1)$ \vspace{-4pt}
		
		$\phantom{w} + \mathbf{S}_u(A',B_2,C_2) - \mathbf{S}_u(A',B_3,C_1) - \mathbf{S}_u(A',B_3,C_2)$ \vspace{-4pt}
		
		$\phantom{w} + \mathbf{S}_u(A',B_2,C_2) - \mathbf{S}_u(A',B_3,C_1) - \mathbf{S}_u(A',B_3,C_2)$;
	\end{itemize}
	where
	\begin{itemize}
		\item[--] if $j \in A$ then $A' = A \cup \{i\}$ and otherwise $A' = A \setminus \{i\}$;
		\item[--] $B_1 = B \cup \{i\} \setminus \{j\}$, $B_2 = B$, $B_3 = B \cup \{i\}$;
		\item[--] $C_1 = C \cup \{i\} \setminus \{j\}$, $C_2 = C$, $C_3 = C \cup \{i\}$.
	\end{itemize}
\end{lemma}

\begin{lemma}[\cite{DBLP:journals/dam/FischerMR08}]
	Let $v$ be a node of $T^{\pm}_F$, $u$ its child, and the operation at $v$ is edge creation $\mu^+_{i,j}(F_u)$ or $\mu^-_{i,j}(F_u)$.
	Then:
	\begin{itemize}
		\item[--] if $i \in A$, then $\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A,B,C)$;
		\item[--] if $j \in B$, then $\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A \cup \{i\},B,C)$;
		\item[--] otherwise, \vspace{-4pt}
		
		$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A,B,C) + \mathbf{S}_u(A \cup \{i\},B \cup \{j\},C) - \mathbf{S}_u(A,B \cup \{j\},C)$.
	\end{itemize}
\end{lemma}
\fi

\begin{algorithm}
	\LinesNumbered
	\caption{Computing $\mathbf{S}_v$ \cite{DBLP:journals/dam/FischerMR08}}
	\label{alg:cw-dynamic}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$v$, an internal node of $T^{\pm}_F$ for clique-width up to $k$}
	\Output{$\mathbf{S}_v$, a table of integers}

	\ForEach{$(A,B,C) \in \{1,2,...,k\}^3$}{
		\tcp{$u$ and eventually $w$ are children of $v$}
		obtain a reference to $\mathbf{S}_u$ and eventually $\mathbf{S}_w$\;
		\uIf{\em the operation at $v$ is $F_u \oplus F_w$}{
			$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A,B,C) \cdot \mathbf{S}_w(A,B,C)$\;
		}
		\uElseIf{\em the operation at $v$ is $\rho_{i,j}(F_u)$}{
			\textbf{if} $j \in A$ \textbf{then} $A' = A \cup \{i\}$ \textbf{else} $A' = A \setminus \{i\}$ \textbf{end}\;
			$B_1 = B \cup \{i\} \setminus \{j\}$, $B_2 = B$, $B_3 = B \cup \{i\}$\;
			$C_1 = C \cup \{i\} \setminus \{j\}$,\, $C_2 = C$, $C_3 = C \cup \{i\}$\;
			\uIf{\em if $j \not\in B$ and $j \not\in C$}{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B,C)$\;
			}
			\uElseIf{\em $j \in B$ and $j \not\in C$}{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B_1,C) + \mathbf{S}_u(A',B_2,C) - \mathbf{S}_u(A',B_3,C)$\;
			}
			\uElseIf{\em $j \not\in B$ and $j \in C$}{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B,C_1) + \mathbf{S}_u(A',B,C_2) - \mathbf{S}_u(A',B,C_3)$\;
			}
			\uElseIf{\em $j \in B$ and $j \in C$}{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A',B_1,C_1) + \mathbf{S}_u(A',B_1,C_2) + \mathbf{S}_u(A',B_2,C_1)$
				$\phantom{i} + \mathbf{S}_u(A',B_2,C_2) - \mathbf{S}_u(A',B_3,C_1) - \mathbf{S}_u(A',B_3,C_2)$
				$\phantom{i} + \mathbf{S}_u(A',B_2,C_2) - \mathbf{S}_u(A',B_3,C_1) - \mathbf{S}_u(A',B_3,C_2)$\;
			}
			\textbf{end}
		}
		\uElseIf{\em the operation at $v$ is $\mu^+_{i,j}(F_u)$ or $\mu^-_{i,j}(F_u)$}{
			\uIf{\em $i \in A$}{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A,B,C)$\;
			}
			\uElseIf{$j \in B$}{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A \cup \{i\},B,C)$\;
			}
			\uElse{
				$\mathbf{S}_v(A,B,C) = \mathbf{S}_u(A,B,C) + \mathbf{S}_u(A \cup \{i\},B \cup \{j\},C)$
				$\phantom{i} - \mathbf{S}_u(A,B \cup \{j\},C)$\;
			}
			\textbf{end}
		}
		\textbf{end}
	}
	\Return $\mathbf{S}_v$
\end{algorithm}






















