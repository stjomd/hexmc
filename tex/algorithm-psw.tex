\subsection{Computing a branch decomposition}

The algorithm for \#SAT that follows in the next subsection requires a formula and its branch decomposition on input, preferably of as small ps-width as possible.
As no methods for computing branch decompositions with minimal ps-width have been published yet, we opted for an algorithm of Lodha et al. \cite{DBLP:journals/tocl/LodhaOS19}, with the help of which we can minimize the branch-width of the formula's incidence graph.

%Let the depth of a branch decomposition be the radius of its tree.

\begin{theorem}[\cite{DBLP:journals/tocl/LodhaOS19}]
	Given a hypergraph $H$ with $m$ edges and $n$ vertices, we can construct a formula $F(H,w)$ that is satisfiable if and only if $H$ has a branch decomposition of branch-width at most $w$, and that has $\mathcal{O}(m^3 + m^2n^2)$ variables and $\mathcal{O}(m^4n + m^2n^2)$ clauses; and we can construct a branch decomposition from a satisfying assignment in time linear in the number of variables.
\end{theorem}

\noindent
For our purposes, we restrict the edges of the hypergraph $H$ to have a size of exactly two, and as such $H$ degenerates to a graph.
The construction of $F(H,w)$ according to \cite{DBLP:journals/tocl/LodhaOS19} is described next.

In a graph, the {\em eccentricity} of a vertex is the maximum distance between it and any other vertex, and the {\em radius} of a graph is the minimum eccentricity over all vertices.
The {\em depth} of a branch decomposition is the radius of its tree.
We first construct a formula $F(H,w,d)$ that is satisfiable iff $H$ has a branch decomposition of branch-width at most $w$ and depth at most $d$.
Then we choose such $d$ that $F(H,w,d)$ is satisfiable iff $H$ has a branch decomposition of branch-width at most $w$.

Before we proceed, we introduce a way to represent branch decompositions using (weak) partitions.
A {\em weak partition} of a set $S$ is a family $P$ of non-empty, disjoint subsets of $S$.
Let $U(P)$ denote the union of all sets in $P$.
If $S = U(p)$, then $P$ is a (non-weak) partition.
The elements of $P$ are called {\em equivalence classes}.
For two weak partitions $P,P'$, we say $P'$ is a {\em refinement} of $P$ if $U(P) \subseteq U(P')$, and any two elements $x,y \in S$ that are in the same equivalence class of $P$, appear together in one equivalence class of $P'$.
Additionally, if for every $p \in P$ there are $p_1, p_2, ..., p_k$ in $P'$ such that $p \subseteq \bigcup_{1 \leq i \leq k}p_i$, we say $P'$ is a {\em $k$-ary refinement}.
Given a hypergraph $H$, the {\em derivation} of $H$ of length $d$ is a sequence $P_1, P_2, ..., P_d$ of partitions of $E(H)$ such that the following holds:
\begin{enumerate}
	\item $P_1 = \{ \{e\} \, | \, e \in E(H) \}$, and $P_d = \{ E(H) \}$, and
	\item for every $1 \leq i \leq d-2$, $P_i$ is a 2-ary refinement of $P_{i+1}$, and
	\item $P_{d-1}$ is a 3-ary refinement of $P_d$.
\end{enumerate}
The width of a derivation is the maximum size of a set of load vertices $\delta(S)$ in $H$ over all sets $S \in \bigcup_{1\leq i \leq d} P_i$.
We also say $P_i$ is the $i$-th level of the derivation.

\begin{lemma}[\cite{DBLP:journals/tocl/LodhaOS19}]
	Let $H$ be a hypergraph.
	$H$ has a branch decomposition of width at most $w$ and depth at most $d$ if and only if $H$ has a derivation of width at most $w$ and length at most $d$.
\end{lemma}

\noindent
We now describe the construction of $F(H,w,d)$.
We assume the hypergraph $H$ has $m$ edges, $n$ vertices, and its edges and vertices are represented by integers from 1 to $m$ or $n$ respectively.
For two edges $e,f$, we define $e < f$ according to their integer representations.
We introduce the following variables:
\begin{itemize}
	\item[--] {\em set variable} $s(e,f,i)$ is true iff edges $e,f$ are in the same set at level $i$,
	\item[--] {\em leader variable} $l(e,i)$ is true iff $e$ is the smallest edge in some set at level $i$, which is used to identify sets (equivalence classes),
	\item[--] {\em load variable} $c(e,u,i)$ is true iff $u$ is a load vertex of the set containing $e$ at level $i$,
	\item[--] {\em counter variable} $\#(e,u,i,j)$ is true iff $u$ is the lexicographically $j$-th load vertex of the edge $e$ at level $i$.
\end{itemize} 
Then the formula has the following clauses:
\begin{enumerate}
	\item $\neg s(e,f,0) \land s(e,f,d) \land (\neg s(e,f,i) \lor s(e,f,i+1))$,
	 
	for $e,f \in E(H), e<f$, $1 \leq i \leq d$;
	
	\item $\ \ \, (\neg s(e,f,i) \lor \neg s(e,g,i) \lor s(f,g,i))$ \vspace{-4pt}
	
	$\land \, (\neg s(e,f,i) \lor \neg s(f,g,i) \lor s(e,g,i))$ \vspace{-4pt}
	
	$\land \, (\neg s(e,g,i) \lor \neg s(f,g,i) \lor s(e,f,i))$,
	
	for $e,f,g \in E(H), e < f < g$, $1 \leq i \leq d$;
	
	\item $(l(e,i) \lor \bigvee_{f\in E(H), f<e} s(f,e,i)) \land \bigwedge_{f\in E(H), f<e} (\neg l(e,i) \lor \neg s(f,e,i))$,
	
	for $e \in E(H), 1 \leq i \leq d$;
	
	\item $\neg l(e,i) \lor \neg(l,f,i) \lor \neg s(e,f,i+1) \lor l(e,i+1) \lor l(f,i+1)$,
	
	for $e,f \in E(H), e < f, 1 \leq i < d-1$;
	
	\item $\ \ \, \neg l(e,d-1) \lor \neg l(f,d-1) \lor \neg l(g,d-1) \lor \neg s(e,f,d) \lor \neg s(e,g,d)$ \vspace{-4pt}
	
	$\lor\, l(e,d) \lor l(f,d) \lor l(g,d)$,
	
	for $e,f,g \in E(H), e < f < g$;
	
	\item $l(e,i) \lor \neg l(e, i+1)$, for $e \in E(H), 1 \leq i < d$;
	% above were clauses of F(H,d) (in the paper), below the extension to F(H,w,d)
	\item $\neg l(e,i) \lor c(e,u,i) \lor s(\min\{e,f\}, \max\{e,f\}, i) \lor \neg s(\min\{e,g\}, \max\{e,g\}, i)$,
	
	for $e,f,g \in E(H), e\neq f, e\neq g, u \in V(H), u \in f, u \in g, 1 \leq i \leq d$;
	
	\item $\neg l(e,i) \lor s(\min\{e,f\}, \max\{e,f\}, i) \lor c(e,u,i)$,
	
	for $e,f \in E(H), e \neq f, u \in V(H), u \in e, u \in f, 1 \leq i \leq d$;
	
	\item $\neg l(e,i) \lor \neg l(e,i+1) \lor \neg l(e,i+2) \lor \neg c(e,u,i) \lor \neg c(e,u,i+2) \lor c(e,u,i+1)$,
	
	for $e \in E(H), u \in V(H), 1 \leq i \leq d-2$;
	
	\item $(\neg \#(e,u-1,i,j) \lor \#(e,u,i,j)) \land (\neg c(e,u,i) \lor \#(e,u-1,i,j-1) \lor \#(e,u,i,j))$\vspace{-4pt}
	
	$\land \, (\neg c(e,u,i) \lor \neg \#(e,u-1,i,w))$,
	
	for $e \in E(H), 2 \leq u \leq |V(H)|, 1 \leq i \leq d, 1 \leq j \leq w$;
	
	\item $\neg c(e,u,i) \lor \#(e,u,i,1)$, for $e \in E(H), 1 \leq u \leq |V(H)|, 1 \leq i \leq d$.
\end{enumerate}

\noindent
The clauses 1--5 ensure the fulfilment of conditions in the definition of a derivation.
The clauses 6 allow to limit the search space (a non-leader edge at level $i$ cannot become a leader at next levels).
The clauses 7--9 define the load vertices, and the clauses 10--11 restrict the size of sets of load vertices to $w$.
The following lemma lets us fix $d$ to some value, as we are only interested in the width $w$.

\begin{lemma}[\cite{DBLP:journals/tocl/LodhaOS19}]
	Let $H$ be a hypergraph and $e$ the maximum size over all edges of $H$.
	Then the branchwidth of $H$ is at most $w$ if and only if $H$ has a derivation of width at most $w$ and length at most $\lfloor \frac{1}{2} |E(H)| \rfloor - \lceil \frac{w}{e} \rceil + \lceil \log \lfloor \frac{w}{e} \rfloor \rceil$.
\end{lemma}

\noindent
Having obtained a satisfying assignment, we can construct a derivation by looking at the set and leader variables that are set to true.
Then we can transform it into a branch decomposition as follows.
First, we add a leaf for all sets in $P_1$, and then, for every set in $P_2$ that is the union of two sets $S,S'$ in $P_1$, we add an internal node whose children are the nodes corresponding to $S,S'$ (in this case leaves).
This goes on until $P_d$ is reached, where we add a root node whose children are the three nodes corresponding to the sets in $P_{d-1}$.

Although this method allows to compute the exact branch-width, the large amount of variables and clauses in the resulting formula results in large solving times, which would not be practical.
Therefore it is possible to employ a local search algorithm to optimize a branch decomposition obtained by heuristic means.

--------

We propose the diameter method \cite{misc:Hicks04} as a heuristic to obtain a sub-optimal branch decomposition.
A branch decomposition of a graph $G$ is called {\em partial} if its tree contains an internal node with degree larger than three. 
We begin with a partial branch decomposition $(T_1, \gamma)$ where $T_1$ is a star (a tree with $|E(G)|$ leaves, and one internal node $v$ that is adjacent to all the leaves).
One then finds a separation $(A,B)$ of the graph's edges such that $|E(A)|, |E(B)| \geq 2$, and creates a new partial branch decomposition $(T_2, \gamma)$, where $v$ is replaced with two vertices $x$ and $y$, connected by an edge $xy$, and the leaves of $x$ and $y$ correspond to $E(A)$ and $E(B)$, respectively.
A node $a$ with $\deg(a)>3$ is chosen; let $G_a$ be the subgraph of $G$ associated with neighbors of $a$ that are leaves, and $e$ the edge between $a$ and the other internal vertex. \textbf{[unclear - associated? induced?]}
We refer to the load vertices $\delta(e)$ as {\em linking nodes} and find a separation $(X,Y)$ of $G_a$.
Assuming $|X| \leq |Y|$, if $|X|>1$, we create a new partial branch decomposition $(T_3, \gamma)$ with new vertices $x,y$ and edges $ax, ay$, where $x$ has leaves corresponding to $E(X)$ and $y$ leaves corresponding to $E(Y)$.
If $|X|=1$, only one vertex $y$ and the edge $ay$ is created, with leaves of $y$ corresponding to $E(Y)$.
This continues until a (non-partial) branch decomposition is obtained.

The separations are found according to the heuristic.
The {\em diameter} of a graph is the maximum eccentricity over all its vertices.
Assume $(T_i, \gamma)$ is a partial branch decomposition, $a$ an internal node with $\deg(a) > 3$, and $e$ the edge between $a$ and its other internal neighbor.
The separation is chosen as follows.
We label the vertices in $\delta(e)$, as well as vertices with eccentricity equal to the diameter of $G_a$, as {\em source nodes}.
Let $v$ be a source node and $\epsilon$ a real with $0 < \epsilon < 1$.
Sort all nodes according to their distance to $v$ in non-decreasing order, and let $A$ be the set of the first $\lceil \alpha |V(G_a)| \rceil$ and $B$ the set of the last $\lfloor \alpha |V(G_a)| \rfloor$ nodes.

Now we want to compute a separation $(X,Y)$ of $G_a$ such that $A \subseteq V(X),\, B \subseteq V(Y)$ and $|V(X) \cap V(Y)|$ is minimized.
\textbf{[isn't it always 0 as X,Y is a separation?]}
Let $G^-$ be a minor of $G$ with $A$ identified to $v_A$ and $B$ identified to $v_B$.
One then finds sep$(v_A, v_B)$, the smallest vertex cut intersecting all $v_Av_B$-paths.
Label the nodes of sep$(v_A, v_B)$ in $G_a$ as {\em separation nodes}.
In $G_a$, let $sep$ be the amount of separation nodes, $sh$ the amount of nodes that are both linking and separation nodes, $side$ the amount of nodes on one side of the cut but not separation nodes, and $link$ the amount of linking nodes.
Then for a pair $(v, \alpha)$ we can define
\begin{align*}
	work := & \max\{ side + sep,\, link - side - sh + sep \}, \\
	play := & \min\{ side + sep,\, link - side - sh + sep \}.
\end{align*}
Iterate over all source nodes and different values of $\alpha$ and find the pair $(v_o, \alpha_o)$ with the smallest $work$, and the biggest $play$ out of pairs with the same work.

We can use a branch decomposition obtained by this heuristic in the following local improvement algorithm, which has been described in \cite{DBLP:journals/tocl/LodhaOS19}.
Let $H$ be a hypergraph and $B=(T,\gamma)$ its branch decomposition.
For a connected ternary subtree $T_L$ of $T$, the {\em local branch decomposition} is the pair $B_L=(T_l, \gamma_L)$ with $\gamma_L(l) = \delta_B(e)$, where $l$ is a leaf of $T_L$, $e$ the unique edge incident to $l$ in $T_L$, and $\delta_B(e)$ is the set of load vertices of $e$ in $B$.
Moreover, $H(T_L)$ is the hypergraph with a hyperedge $\gamma_L(l)$ for each leaf $l$ of $T_L$, and with vertices that are the union of all these edges.  
The idea behind local improvement is that we can obtain a (possibly more optimal) branch decomposition of $H$ by modifying $B$: in particular by replacing the part formed by $B_L$ with any branch decomposition of $H(T_L)$.
See Algorithms \ref{alg:ps-bd-main}, \ref{alg:ps-bd-localbd}, \ref{alg:ps-bd-improveld} for details.

%local improvement
\begin{algorithm}
	\LinesNumbered
	\caption{Local improvement \cite{DBLP:journals/tocl/LodhaOS19}}
	\label{alg:ps-bd-main}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$H$, a hypergraph}
	\Output{A branch decomposition of $H$}

	$B \gets $ compute a branch decomposition with a heuristic; \tcp{$B = (T, \gamma)$}
	$improved \gets \textsf{true}$\;
	\While{$improved$}{
		$M \gets \text{the set of edges $e$ of $B$ whose $|\delta_B(e)|$ is maximum}$\;
		$C \gets \text{the set of components of $T[M]$}$\;
		$improved \gets \textsf{false}$\;
		\ForEach{$c \in C$}{
			$B_L \gets \mathtt{LocalBD}(B, C)$; \tcp{See Algorithm \ref{alg:ps-bd-localbd}}
			$B'_L \gets \mathtt{ImproveLD}(B_L)$; \tcp{See Algorithm \ref{alg:ps-bd-improveld}}
			\uIf{$B'_L \neq \mathsf{null}$}{
				$B \gets \texttt{Replace}(B, B_L, B'_L)$\;
				$improved \gets \textsf{true}$\;
			}
			\uElse{
				break\;
			}
			\textbf{end}
		}
	}
	\Return $B$\;
\end{algorithm}

\begin{algorithm}
	\LinesNumbered
	\caption{\texttt{LocalBD} \cite{DBLP:journals/tocl/LodhaOS19}}
	\label{alg:ps-bd-localbd}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$B = (T, \gamma)$, a branch decomposition of hypergraph $H$, and a component $C$ of $T$}
	\Output{A local branch decomposition of $B$}

	$w \gets \text{the width of } B$\;
	$T_L \gets C$\;
	\ForEach{$c \in V(H),\, \deg_C(c)=2$}{
		add the unique third neighbor and its edge, incident to $c$, to $T_L$; 
	}
	$Q \gets $ a queue containing the leaves of $T_L$\;
	\While{$Q \neq 0, |T_L| \leq globalbudget-2$}{
		$l \gets Q.$pop()\;
		\If{{\em $l$ is not a leaf of $T$}}{
			$c,c' \gets $ two neighbors of $l$ in $T$ that are not neighbors of $l$ in $T_L$\;
			\If{$\delta_B(\{l,c\}) < w,\, \delta_B(\{l,c'\}) < w$}{
				add $c,c'$ together with their edges, incident to $l$, to $T_L$\;
				$Q$.push($c$)\;
				$Q$.push($c'$)\;
			}
		}
	}
	\Return the local branch decomposition of $B$ represented by $T_L$\;
\end{algorithm}

\begin{algorithm}
	\LinesNumbered
	\caption{\texttt{ImproveLD} \cite{DBLP:journals/tocl/LodhaOS19}}
	\label{alg:ps-bd-improveld}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$B_L = (T_L, \gamma_L)$, a branch decomposition of hypergraph $H(T_L)$}
	\Output{An improved branch decomposition of $H(T_L)$}

	\If{$|T_L| > globalbudget$}{
		\Return \textsf{null}\;
	}
	$w \gets $ the width of $B_L$\;
	\Repeat{$B_D = \mathsf{null}$}{
		$B_D \gets \texttt{SATSolve}(H(T_L), w)$\;
		\If{$B_d \neq \mathsf{null}$}{
			$B'_L \gets B_D$\;
		}
		$w \gets w - 1$\;
	}
	\Return $B'_L$\;
\end{algorithm}











% dynamic algorithm
\subsection{Dynamic algorithm for \#SAT}

Recall that for a CNF formula $F$, var$(F)$ denotes the set of variables and cla$(F)$ the set of clauses of $F$;
similarly by var$(C)$ we denote the corresponding set on clauses.
Moreover, we define lit$(C)$ to be the set of literals in clause $C$.
As an example, for $F = \{ C_1, C_2 \}$ with $C_2 = \{ x_1, \neg x_2 \}$ we have var$(C_2) = \{ x_1, x_2 \}$ and cla$(C_2) = \{ x_1, \neg x_2 \}$.

In this section, we solve \#SAT using an FP algorithm (with the parameter being the ps-width of the formula).

\begin{theorem}
	Given a CNF formula $F$ with $n$ variables and $m$ clauses, of size $s$ and of ps-width $k$, \#SAT can be solved in time $\mathcal{O}(k^3s(m+n))$.
	
	\textbf{Make sure complexity includes computing the branch dcmp!}
\end{theorem}

\noindent
{\em Proof.}
The sketch of the proof is as follows.
First, we show that a branch decomposition of a formula can be computed in polynomial time. TODO!
With that at hand, we present an FP algorithm of S\ae ther, Telle and Vatshelle \cite{DBLP:conf/sat/SaetherTV14} that, given a formula and its branch decomposition, solves \#SAT in polynomial time.

The following steps are as described by S\ae ther, Telle and Vatshelle in \cite{DBLP:conf/sat/SaetherTV14}.
The definition of ps-width relies upon precisely satisfiable sets of a formula, which need to be computed in order for the algorithm to proceed.
Thus:

\begin{lemma}[\cite{DBLP:conf/sat/SaetherTV14}]
	Given a CNF formula $F$ with $n$ variables and $m$ clauses, and a branch decomposition $(T, \delta)$ of ps-width $k$, the sets $\mathcal{PS}(F_v)$ and $\mathcal{PS}(F_{\overline{v}})$, for some $v \in V(T)$, can be computed in time $\mathcal{O}(k^2 \log(k) m(m+n))$.
\end{lemma}

% algorithms for PS-sets
\begin{algorithm}
	\LinesNumbered
	\caption{Computing $\mathcal{PS}(F_v)$ \cite{DBLP:conf/sat/SaetherTV14}}
	\label{alg:ps-f-v}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$\mathcal{PS}(F_{c_1})$ and $\mathcal{PS}(F_{c_2})$, where $c_1, c_2$ are either children of $v$ in $(T, \delta)$}
	\Output{$\mathcal{PS}(F_v)$}

	$L \gets \emptyset$\;
	\ForEach{$(C_1, C_2) \in \mathcal{PS}(F_{c_1}) \times \mathcal{PS}(F_{c_2})$}{
		$C \gets (C_1 \cup C_2) \setminus \text{cla}(\delta(v))$\;
		$L \gets L \cup \{ C \}$\;
	}
	\Return $L$
\end{algorithm}

\begin{algorithm}
	\LinesNumbered
	\caption{Computing $\mathcal{PS}(F_{\overline{v}})$ \cite{DBLP:conf/sat/SaetherTV14}}
	\label{alg:ps-f-negv}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$\mathcal{PS}(F_s)$ and $\mathcal{PS}(F_{\overline{p}})$, where $s$ is the sibling, and $p$ is the parent of $v$ in $(T, \delta)$}
	\Output{$\mathcal{PS}(F_{\overline{v}})$}

	$L \gets \emptyset$\;
	\ForEach{$(C_s, C_p) \in \mathcal{PS}(F_s) \times \mathcal{PS}(F_{\overline{p}})$}{
		$C \gets (C_s \cup C_p) \setminus \text{cla}(\delta(v))$\;
		$L \gets L \cup \{ C \}$\;
	}
	\Return $L$
\end{algorithm}

Computing both sets is identical in procedure and only differs by the inputs.
For $\mathcal{PS}(F_v)$, the precisely satisfiable sets at the children nodes are required; for $\mathcal{PS}(F_{\overline{v}})$, the precisely satisfiable sets of the sibling and the parent node.
This has to do with the fact that both sets can be expressed as follows:
\begin{align*}
	\mathcal{FS}(F_v) &= \{ (C_1 \cup C_2) \cap \text{cla}(F_v) \; | \; C_1 \in \mathcal{PS}(F_{c_1}), C_2 \in \mathcal{PS}(F_{c_2}) \},\\
	\mathcal{FS}(F_{\overline{v}}) &= \{ (C_1 \cup C_2) \cap \text{cla}(F_{\overline{v}}) \; | \; C_1 \in \mathcal{PS}(F_s), C_2 \in \mathcal{PS}(F_{\overline{p}}) \}
\end{align*}

\noindent
for a node $v$ in $(T, \delta)$, where $c_1, c_2$ are children of $v$, and $s, p$ are the sibling and the parent of $v$, respectively.
These recursive relations translate into iterative, dynamic algorithms, refer to Algorithms \ref{alg:ps-f-v} and \ref{alg:ps-f-negv}.
Base cases $\mathcal{PS}(F_l)$ for leaves $l$ and $\mathcal{PS}(F_{\overline{r}})$ for root $r$ can be computed in linear time, as these formulas contain up to one variable.

With a way to compute precisely satisfiable sets of clauses, we can proceed to the main part of the \#SAT algorithm.
For every node $v$ in the branch decomposition, we will compute a table $\mathbf{Tab}_v$ indexed by elements in the product $\mathcal{PS}(F_v) \times \mathcal{PS}(F_{\overline{v}})$.
Each table must fulfil the following constraint:
\begin{equation}
	\mathbf{Tab}_v(C_1, C_2) = |\{ \tau \; | \; \text{sat}(F_v, \tau) = C_1, \, \text{cla}(\delta(v)) \setminus C_2 \subseteq \text{sat}(F, \tau) \}|
	\label{psw:constraint}
\end{equation}
where $C_1 \in \mathcal{PS}(F_v)$, $C_2 \in \mathcal{PS}(F_{\overline{v}})$, $\tau$ is an assignment over var$(\delta(v))$, and sat$(F,\tau) \subseteq \text{cla}(F)$ is a subset of clauses of $F$ such that $\tau$ only satisfies the clauses in this subset and no other clauses.
This constraint ensures that each table stores the partial solutions to the problem.

Let the size of formula $F$ be $s = |\text{cla}(F)| + \sum_{C \in \text{cla}(F)} |\text{lit}(C)|$.

\begin{lemma}[\cite{DBLP:conf/sat/SaetherTV14}]
	Given a CNF formula $F$ of size $s$, as well as a branch decomposition $(T, \delta)$ of ps-width $k$, $\mathbf{Tab}_v$ that satisfies Constraint \ref{psw:constraint} can be computed for an internal node $v \in V(T)$ in time $\mathcal{O}(k^3s)$.
\end{lemma}

The computation of $\mathbf{Tab}_v$ depends on two tables $\mathbf{Tab}_{c_1}$ and $\mathbf{Tab}_{c_2}$ that correspond to the children nodes $c_1, c_2$ of $v$ in the branch decomposition.
See Algorithm \ref{alg:ps-tab-v} for how the computation is performed.
For leaves of the branch decomposition, each entry of $\mathbf{Tab}_l$ is set to either 0, 1, or 2, according to the definition. \textbf{[NOTE:] which def?}

After proceeding on all nodes, the number of satisfying assignments is stored in $\mathbf{Tab}_r(\emptyset, \emptyset)$ at the root $r$ of $(T, \delta)$.

\begin{algorithm}
	\LinesNumbered
	\caption{Computing $\mathbf{Tab}_v$ \cite{DBLP:conf/sat/SaetherTV14}}
	\label{alg:ps-tab-v}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$\mathbf{Tab}_{c_1}$, $\mathbf{Tab}_{c_2}$, where $c_1, c_2$ are children of internal node $v$}
	\Output{$\mathbf{Tab}_v$ that satisfies Constraint \ref{psw:constraint}}

	$\mathbf{Tab}_v : \mathcal{PS}(F_v) \times \mathcal{PS}(F_{\overline{v}}) \gets \{ \{ 0, 0, ... \}, \{ 0, 0, ... \}, ... \}$\; 
	\ForEach{$(C_{c_1}, C_{c_2}, C_{\overline{v}}) \in \mathcal{PS}(F_{c_1}) \times \mathcal{PS}(F_{c_2}) \times \mathcal{PS}(F_{\overline{v}})$}{
		$C_{\overline{c_1}} \gets (C_{c_2} \cup C_{\overline{v}}) \cap \delta(c_1)$\;
		$C_{\overline{c_2}} \gets (C_{c_1} \cup C_{\overline{v}}) \cap \delta(c_2)$\;
		$C_{v} \ \gets (C_{c_1} \cup C_{c_2}) \setminus \delta(v)$\;
		$\mathbf{Tab}_v(C_v, C_{\overline{v}}) \gets \mathbf{Tab}_v(C_v, C_{\overline{v}}) + \mathbf{Tab}_{c_1}(C_{c_1}, C_{\overline{c_1}}) + \mathbf{Tab}_{c_2}(C_{c_2}, C_{\overline{c_2}})$\;
	}
	
	\Return $\mathbf{Tab}_v$
\end{algorithm}

As such we solve \#SAT in time $\mathcal{O}(k^3s(m+n))$, where $n$ is the amount of variables, $m$ the amount of clauses, $s$ the size, and $k$ the ps-width of the branch decomposition of the formula.


% interval graphs
\subsection{Complexity improvements}

The cubic factor $k^3$ in the algorithm utilizing the ps-width of a formula is due to the amount of triples in $\mathcal{PS}(F_{c_1}) \times \mathcal{PS}(F_{c_2}) \times \mathcal{PS}(F_{\overline{v}})$ for every node $v$ with children $c_1, c_2$ \cite{DBLP:conf/sat/SaetherTV14}.
In some cases, it is possible to bring the factor down to $k^2$.

A branch decomposition is called {\em linear} if all its internal nodes induce a path.
In that case, for any node $v$, either $c_1$ or $c_2$ is a leaf, and as such, either $|\mathcal{PS}(F_{c_1})|$ or $|\mathcal{PS}(F_{c_2})|$ is a constant.
The consequence is that $\mathcal{PS}(F_{c_1}) \times \mathcal{PS}(F_{c_2}) \times \mathcal{PS}(F_{\overline{v}})$ has $\mathcal{O}(k^2)$ triples, and the following thus holds:

\begin{theorem}
	Given a CNF formula $F$ with $n$ variables and $m$ clauses, of size $s$ and of ps-width $k$, that admits a linear branch decomposition, \#SAT can be solved in time $\mathcal{O}(k^2s(m+n))$.
	
	\textbf{Make sure complexity includes computing the branch dcmp!}
	\label{theorem:sat-linear-bd}
\end{theorem}

There is a class of formulas for which we can construct a linear branch decomposition, namely formulas with interval orderings, and as such use the results of Theorem \ref{theorem:sat-linear-bd}. 

\begin{theorem}[\cite{DBLP:conf/sat/SaetherTV14}]
	Given a CNF formula $F$ with $n$ variables, $m$ clauses, and of size $s$, it is possible to check whether $F$ has an interval ordering in time $\mathcal{O}(s(m+n))$, and if it does, solve \#SAT in time $\mathcal{O}(m^2s(m+n))$.
\end{theorem}

\noindent
We get the complexity result for \#SAT by combining the results of Theorem \ref{theorem:sat-linear-bd} and Fact \ref{fact:psw-interval}.
We can check whether $F$ has an incidence graph that is an interval bigraph, and as such whether $F$ has an interval ordering, using an algorithm by Rafiey \cite{DBLP:journals/corr/abs-1211-2662}, described next (see also Algorithm \ref{alg:interval-bigraph}).

For a connected bigraph $G$, the {\em pair-digraph} $G^+$ is a directed graph whose vertices are pairs $(u,v) \in V(G),\, u \neq v$.
$G^+$ has edges from $(u,v)$ to $(u',v)$ when $u,v$ are in the same partition of $G$ and $uu' \in E(G),\, vu' \not\in E(G)$; and it also has edges from $(u,v)$ to $(u,v')$ when $u,v$ are in different partitions of $G$ and $vv' \in E(G),\, uv \not\in E(G)$.
For $\alpha, \beta \in V(G^+)$ we also write $\alpha \rightarrow \beta$ if there exists an edge from $\alpha$ to $\beta$.
For a subset $D \subseteq V(G^+)$, a {\em circuit} is a sequence of pairs $(x_0, x_1), (x_1, x_2), ..., (x_n, x_0)$ from $D$.

For a subset $R \subseteq V(G^+)$, the {\em out-section} $N^+[R]$ of $R$ is the set of pairs  $\{ (u, v) \, | \, \exists (u',v') : (u',v') \rightarrow (u,v) \}$.
The {\em envelope} $N^*[R]$ is the smallest set of pairs that contains $R$ and is closed under transitivity and out-section.

For a (strong) component $S$ of $G^+$, the {\em couple component} $S'$ contains swapped pairs, i.e. $S' = \{ (u,v) \, | \, (v,u) \in S \}$.
If $S = S'$, the component $S$ is said to be {\em self-coupled.}
A component is called {\em trivial} if it contains exactly one pair, a {\em source component} if it is trivial and its vertex (pair) has in-degree zero, and a {\em sink component} if it is trivial and its vertex has out-degree zero.

Given a set $R = \{ R_1, R_2, ..., R_k, S \}$ of components of $G^+$ s.t. $N^*[R]$ contains a circuit $C$, and an arbitrary $W \subseteq R \setminus \{S\}$ with $W' = \{ R'_i \, | \, R_i \in W\}$, $S$ is said to be a {\em dictator} for $C$ if $N^*[W' \cup (R \setminus W)]$ also contains a circuit.

The algorithm operates as follows.
Given a bipartite graph $G$, we first compute $G^+$.
If there are any self-coupled components, we can immediately conclude that $G$ is not an interval bigraph.

Otherwise we initialize an empty set $D$ and consider pairs of coupled components $S, S'$.
If $D \cup N^+[S]$ contains no circuits, we add all the pairs in $N^+[S]$ to $D$, and discard $N^+[S']$; otherwise we add the pairs in $N^+[S']$ and discard $N^+[S]$.
If $D$ has a circuit we can again conclude that $G$ is not an interval bigraph, and if we can select exactly one of $S, S'$ in $G^+$, we proceed next.

The algorithm then calculates $N^*[D]$ while filling the set $\mathcal{DT}$ of dictator components.
Then, we create an empty set $D_1$, and for every $S_1 \in \mathcal{DT}$ add the pairs in $N^+[S'_1]$ to $D_1$ [and discard $N^+[S_1]$].
For every $S_2 \in D \setminus \mathcal{DT}$, we add the pairs in $N^+[S_2]$ to $D_1$ [and discard $N^+[S'_2]$].
Finally we set $D=N^*[D_1]$ and check for circuits in $D$.
If they are present, we conclude $G$ is not an interval bigraph.

Otherwise we add the remaining components of $H^+$ outside $D$, into $D$, while adding a sink components $S \subseteq V(H^+) \setminus D$, and discard $S'$.
Finally, we go through the set $D$ and set the ordering $<$ for every pair $(u,v)$ as $u < v$.
Then we can sort through the result and return the interval ordering.

\begin{algorithm}
	\LinesNumbered
	\caption{Recognizing an interval bigraph \cite{DBLP:journals/corr/abs-1211-2662}}
	\label{alg:interval-bigraph}
	
	\SetKwInput{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$G$, a connected bigraph with $V(G) = B \cup W$}
	\Output{An interval ordering of the vertices of $G$, or \textsf{false} if $G$ is not an interval bigraph}
	
	\SetKwFunction{FIntOrdering}{intervalOrdering}
  	\SetKwProg{Fn}{Function}{:}{}
  	\Fn{\FIntOrdering{$G$}}{
        %a\;
        %b\;
        %\KwRet\;
  	%}

	Construct $G^+$; if there are self-coupled components, return \textsf{false}\;
	\tcc{Step 1}
	$D \gets \emptyset$\;
	\ForAll{{\em coupled components $S,S' \subseteq V(G^+)$}}{
		\uIf{{\em no circuit in $D \cup N^+[S]$}}{
			\ForAll{$(x,y) \in N^+[S]$}{
				$D \gets D \cup \{(x,y)\}$, $DCT(x,y) := S$\;
			}
			remove $N^+[S]$ from consideration in this step
		}
		\uElseIf{{\em no circuit in $D \cup N^+[S']$}}{
			\ForAll{$(x,y) \in N^+[S']$}{
				$D \gets D \cup \{(x,y)\}$, $DCT(x,y) := S'$\;
			}
			remove $N^+[S']$ from consideration in this step
		}
		\uElse{\Return \textsf{false}\;}
		\textbf{end}
	}
	
	\tcc{Step 2}
	$E \gets N^*[D], \mathcal{DT} \gets \emptyset$\;
	\While{$\exists (x,y) \in E \setminus D$}{
		$D \gets D \cup \{(x,y)\}, \; E \gets E \setminus \{(x,y)\}$\;
		$DCT(x,y) = \mathtt{dictator}(x,y,D)$\;
		\If{{\em there is a circuit in $D \cup \{(x,y)\}$}}{
			$\mathcal{DT} \gets \mathcal{DT} \cup \{DCT(x,y)\}$
		}
	}
	
	\tcc{Step 3}
	$D_1 \gets \emptyset$\;
	\ForAll{$S \in \mathcal{DT}$}{
		$D_1 \gets D_1 \cup  N^+[S']$\;
	}
	\ForAll{$R \in D \setminus \mathcal{DT}$}{
		$D_1 \gets D_1 \cup  N^+[R] $\;
	}
	$D \gets N^*[D_1]$\;
	\If{{\em there is a circuit in $D$}}{
		\Return \textsf{false}\;
	}
	\tcc{Step 4}
	%\While{{\em $\exists S \not\in D$, $S$ is a sink component}}{
	%	$D \gets D \cup S$\;
	%	??? remove $S'$ from further consideration
	%}
	%\ForAll{$(u,v) \in D$}{set $u < v$\;}
	%
	%\Return $v_1, v_2, ..., v_n$ such that $v_i < v_{i+1}$ for $1 \leq i < n$\;
	}
\end{algorithm}

\begin{algorithm}
	\LinesNumbered
	%\caption{Recognizing an interval bigraph \cite{DBLP:journals/corr/abs-1211-2662}}
	%\label{alg:ps-f-v}
	
	%\SetKwInput{Input}{Input}
	%\SetKwInOut{Output}{Output}
	%\Input{$G$, a connected bigraph with $V(G) = B \cup W$}
	%\Output{An interval ordering of the vertices of $G$, or \textsf{false} if $G$ is not an interval bigraph}
	
	\SetKwBlock{IndentBlock}{\texttt{\hspace{1em} /* Step 4 \hspace{22em} */}}{}
	
  	\IndentBlock{
		%\tcc{Step 4}
		\While{{\em $\exists S \not\in D$, $S$ is a sink component}}{
			$D \gets D \cup S$\;
			remove $S'$ from further consideration
		}
		\ForAll{$(u,v) \in D$}{set $u < v$\;}
		\Return $v_1, v_2, ..., v_n$ such that $v_i < v_{i+1}$ for $1 \leq i < n$\;
	}
	\phantom{}
	\SetKwFunction{FDictator}{dictator}
  	\SetKwProg{Fn}{Function}{:}{}
  	\Fn{\FDictator{$x,y,D$}}{
		\uIf{$(x,y) \in N^+[S]$ {\em for some $S$ in $D$}}{
			\Return $S$\;			
		}
		\uElseIf{{\em $x,y$ from different partitions, $(u,y) \rightarrow (x,y), (u,y) \in D$}}{
			\Return $DCT(u,y)$\;
		}
		\uElseIf{{\em $x,y$ from same partition, $(x,w) \rightarrow (x,y), (x,w) \in D$}}{
			\Return $DCT(x,w)$\;
		}
		\uElseIf{{\em $x,y$ from same partition, $(x,y)$ is by transitivity on $(x,w), (w,y) \in D$}}{
			\Return $DCT(w,y)$\;
		}
		\uElseIf{{\em $x,y$ from different partitions, $(x,y)$ is by transitivity on $(x,w), (w,y) \in D$}}{
			\Return $DCT(x,w)$\;
		}
	}
\end{algorithm}

For a graph $G$ with $|V|$ vertices and $|E|$ edges, the complexity of Algorithm \ref{alg:interval-bigraph} is $\mathcal{O}(|V||E|)$ \cite{DBLP:journals/corr/abs-1211-2662}.
In our case, $G$ is the incidence graph of a formula, and as such $|V|=m+n$ and $|E| = s$, where $m,n,s$ are the amount of clauses, variables, and the size of the formula, respectively.
Thus we can compute the interval ordering for an incidence graph of a formula, provided it exists, in time $\mathcal{O}(s(m+n))$.










